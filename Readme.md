- 생성 패턴

생성 패턴은 객체의 생성과 관련된 패턴이다. 객체의 인스턴스 과정을 추상화하는 방법이다. 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램에 유연성을 더해준다. 생성 클래스 패턴은 객체를 생성하는 일부를 서브클래스가 담당하도록 하며, 생성 객체 패턴은 객체 생성을 다른 객체에게 위임한다.

```
- 추상 팩토리(Abstract Factory) : 구체적인 클래스를 지정하지 않고 인터페이스를 통해 서로 연관되는 객체들을 그룹으로 표현함
- 빌더(Builder) : 복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어낼 수 있음
- 팩토리 메소드(Factory Method) : 객체 생성을 서브클래스로 위임하여 캡슐화함
- 프로토타입(Prototype) : 원본 객체를 복사함으로써 객체를 생성함
- 싱글톤(Singleton) : 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함
```

- 구조 패턴

구조 패턴은 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴이다. 구조 클래스 패턴은 상속을 통해 클래스나 인터페이스를 합성하고, 구조 객체 패턴은 객체를 합성하는 방법을 정의한다.

```
- 어댑터(Adapter) : 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함
- 브리지(Bridge) : 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함
- 컴포지트(Composite) : 객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룸
- 데코레이터(Decorator) : 주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식
- 퍼싸드(Facade) : 서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공
- 플라이웨이트(Flyweight) : 크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약함
- 프록시(Proxy) : 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate나 Placeholder를 제공
```

- 행위 패턴

행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지를 정의하는 패턴이다. 즉, 객체나 클래스의 교류 방법에 대해 정의하는 것이다. 행위 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 그들 간의 결합도를 최소화 할 수 있도록 도와준다. 행위 클래스 패턴은 상속을 통해 알고리즘과 제어 흐름을 기술하고, 행위 객체 해턴은 하나의 작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술한다.

```
- 책임 연쇄(Chain of Responsibility) : 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달함
- 커맨드(Command) : 요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장함
- 인터프리터(Interpreter) : 특정 언어의 문법 표현을 정의함
- 반복자(Iterator) : 내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공
- 중재자(Mediator) : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의
- 메멘토(Memento) : 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화
- 옵서버(Observer) : 객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함
- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용
- 전략(Strategy) : 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함
- 템플릿 메소드(Template Method) : 상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 위임함
- 방문자(Visitor) : 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성함
```

Iterator 패턴

```
- Iterator 패턴은 배열이나 Linked-List, Tree 처럼 다른 데이터 구조를 갖는 Aggregator의 구성 항목을 표준화된 공통 API로 접근할 수 있습니다.
- 데이터 구조가 다른 Aggregator일지라도 구성항목을 표준화된 공통 API로 접근할 수 있음으로 하느이 공통된 알고리즘으로 처리할 수 있습니다
```

Strategy 패턴

```
- Strategy 패턴은 어떤 기능에 대한 특정 알고리즘을 느슨하게 결합시켜주는 패턴입니다.
- 어떤 알고리즘이 느슨하게 결합되면 추후 더 나은 알고리즘으로 쉽게 변경할 수 있을 뿐만 아니라 프로그램이 실행 중에 상황에 맞는 알고리즘으로 쉽게 변경할 수 있습니다.
- 또한 기존의 알고리즘을 유지하면서 새로운 알고리즘을 효과적으로 추가할 수 있습니다.
```

Template method 패턴

```
- Template method 패턴은 어떤 기능을 구성하는 각 실행 순서를 미리 정하고 각 실행 단계에 대한 구체적인 코드를 재정의할 수 있는 유연성을 제공합니다.
```

Adapter 패턴

```
- Adapter 패턴은 코드를 변경할 수 없는 클래스를 원하는 형태로 사용하고자 할때 적용할수 있는 패턴입니다.

- 클래스의 코드를 변경하기 어려운 경우
1. 처음푸터 코드가 제공되지 안흔 클래스의 경우(컴파일 언어인 경우에 한함)
2. 이미 많은 프로그램에서 사용되는 공용 클래스로써 고용 클래스가 변경되면 영향을 받는 다른 프로그램의 코드가 너무 많이 변경되는 경우
3. 어떤 클래스가 번전업된 경우 하위버전의 클래스도 지원해야 하는 경우
```

Bridge 패턴

```
- Bridge 패턴은 기능 계층과 구현 계층을 분리합니다
- 새로운 기능을 추가할 떄는 기능 계층을 확장하고 새로운 구현을 추가할때는 구현 계층을 확장함으로써 복잡도를 효과적으로 낮출수 있습니다.
- 기능 계층과 구현 계층은 서로 위임을 통해서 통신합니다.
- 클래스들간의 관계는 단순하게 만들어 주는 것이 좋은데 Bridge 패턴은 기능 계층과 구현 계층을 분리함으로써 클래스들 간의 관계를 단순하게 유지시켜 줍니다.
```

Decorator 패턴

```
- Decorator 패턴은 어떤 객체에 기능을 적용할 떄 그 객체와 적용될 기능을 동일시할 수 있음
- 데이터와 기능을 동일시할 수 있으므로 다양한 기능을 중첩해서 적용할 수 있으며 적용되는 기능의 순서에 따라 다른 결과를 얻을 수 있음
```

Singleton 패턴

```
- Singleton 패턴은 특정 클래스의 인스턴스가 오직 한 개만 존재한다는 것을 보장합니다.
- Singleton 패턴이 적용된 클래스의 인스턴스는 미리 생성해 놓거나 사용될떄 생성되는것이 가능합니다.
```

Flyweight 패턴

```
- Flyweight 패턴은 동일한 객체를 여러 번 생성하지 않고 미리 생성해 두고 공유해 사용할 수 있음
- Flyweight 패턴을 통해 미리 생성해둔 객체는 공유의 개념으로 사용되므로 공유할 속성과 공유하지 않을 속성을 구분하여 설계할 필요가 있음
```

Composite 패턴

```
- Composite 패턴은 집합체와 집합체를 구성하는 항목인 단일체를 같은 개념으로 처리합니다.
- 다양한 형태의 단일체를 조합한 집합체를 또 다른 단일체로 정의할 수 있고 이를 단일체나 집합체라는 구분없이 같은 개념으로 처리할 수 있습니다.
```

Factory Method 패턴

```
- Factory Method 패턴은 객체 생성을 위한 패턴 중에 하나로 객체 생성에 필요한 과정을 템플릿처럼 전해 놓고 각 과정을 다양하게 구현이 가능합니다.
- 객체 생성에 대한 인터페이스와 구현의 분리를 통해 새로운 객체 생성을 유연하게 확장할 수 있습니다.
```

observer 패턴

```
- observer 패턴은 어떤 상태의 변화에 대한 처리를 위해 사용됩니다.
- 상태 변화가 발생하면 상태 변화에 관심을 가지고 있는 객체들에게 상태 변화를 알리며 필요핟마녀 변경된 상태값도 전달합니다.
```

mediator 패턴

```
- mediator 패턴은 많은 객체들 간의 복자한 관계를 중재자를 두어 단순화 시킨다.
- 또한 객체의 상태 변경으로 인해 다른 객체를 제어할 떄 제어에 대한 흩어진 코드를 중재자로 모아 모두 처리해 줌으로써 객체들의 복잡한 관계를 제거합니다.
```

memento 패턴

```
- memento 패턴은 객체의 상태를 기억해 두고 필요할 떄 다시 복원하기 위한 패턴입니다.
- 어떤 기능의 실행 이력보관, 실행취소, 재실행 등의 목정르 위해 활용될 수 있는 패턴
- 이미 기억된 객체의 상태가 변경되지 않도록 주의 해야 한다.
```

proxy 패턴

```
- proxy 패턴의 종류에는 가상 원격 보호 등이 있습니다.
- 가상은 필요한 시점까지 객체의 생성을 연기하고 마치 생성된 것처럼 동작하다가 필요한 시점에 실제 객체를 생성해서 사용함
- 실제 기능 실행을 대리인을 통해 실행하도록 하는 것이 근본적인 목적임
```

chain of responsibility 패턴

```
- chain of responsibility 패턴은 기능 단위로 클래스를 분리하고 이 클래스의 객체를 연결하여 각 기능을 지정된 순서로 실행할 수 있느 패턴입니다.
- 기능을 클래스 별로 분리하여 구현하도록 유도하므로 객체지향설계 원칙 중 단일 책임 원칙 및 개방폐쇠원칙 등을 자연스럽게 따르게 된다.
```

prototype 패턴

```
- prototype 패턴은 객체를 클래스 이름으로 생성하지 않고 실행 중에 생성된 객체를 통해 동일한 상태값으로 새로운 객체를 생성하는 패턴
- 원본 객체에 대한 깊은 복사를 사용하여 변경에 대해 서로 다른 쪽에 영향을 주지 않습니다.
```
