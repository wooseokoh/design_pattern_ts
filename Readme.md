Iterator 패턴

```
- Iterator 패턴은 배열이나 Linked-List, Tree 처럼 다른 데이터 구조를 갖는 Aggregator의 구성 항목을 표준화된 공통 API로 접근할 수 있습니다.
- 데이터 구조가 다른 Aggregator일지라도 구성항목을 표준화된 공통 API로 접근할 수 있음으로 하느이 공통된 알고리즘으로 처리할 수 있습니다
```

Strategy 패턴

```
- Strategy 패턴은 어떤 기능에 대한 특정 알고리즘을 느슨하게 결합시켜주는 패턴입니다.
- 어떤 알고리즘이 느슨하게 결합되면 추후 더 나은 알고리즘으로 쉽게 변경할 수 있을 뿐만 아니라 프로그램이 실행 중에 상황에 맞는 알고리즘으로 쉽게 변경할 수 있습니다.
- 또한 기존의 알고리즘을 유지하면서 새로운 알고리즘을 효과적으로 추가할 수 있습니다.
```

Template method 패턴

```
- Template method 패턴은 어떤 기능을 구성하는 각 실행 순서를 미리 정하고 각 실행 단계에 대한 구체적인 코드를 재정의할 수 있는 유연성을 제공합니다.
```

Adapter 패턴

```
- Adapter 패턴은 코드를 변경할 수 없는 클래스를 원하는 형태로 사용하고자 할때 적용할수 있는 패턴입니다.

- 클래스의 코드를 변경하기 어려운 경우
1. 처음푸터 코드가 제공되지 안흔 클래스의 경우(컴파일 언어인 경우에 한함)
2. 이미 많은 프로그램에서 사용되는 공용 클래스로써 고용 클래스가 변경되면 영향을 받는 다른 프로그램의 코드가 너무 많이 변경되는 경우
3. 어떤 클래스가 번전업된 경우 하위버전의 클래스도 지원해야 하는 경우
```

Bridge 패턴

```
- Bridge 패턴은 기능 계층과 구현 계층을 분리합니다
- 새로운 기능을 추가할 떄는 기능 계층을 확장하고 새로운 구현을 추가할때는 구현 계층을 확장함으로써 복잡도를 효과적으로 낮출수 있습니다.
- 기능 계층과 구현 계층은 서로 위임을 통해서 통신합니다.
- 클래스들간의 관계는 단순하게 만들어 주는 것이 좋은데 Bridge 패턴은 기능 계층과 구현 계층을 분리함으로써 클래스들 간의 관계를 단순하게 유지시켜 줍니다.
```

Decorator 패턴

```
- Decorator 패턴은 어떤 객체에 기능을 적용할 떄 그 객체와 적용될 기능을 동일시할 수 있음
- 데이터와 기능을 동일시할 수 있으므로 다양한 기능을 중첩해서 적용할 수 있으며 적용되는 기능의 순서에 따라 다른 결과를 얻을 수 있음
```

Singleton 패턴

```
- Singleton 패턴은 특정 클래스의 인스턴스가 오직 한 개만 존재한다는 것을 보장합니다.
- Singleton 패턴이 적용된 클래스의 인스턴스는 미리 생성해 놓거나 사용될떄 생성되는것이 가능합니다.
```

Flyweight 패턴

```
- Flyweight 패턴은 동일한 객체를 여러 번 생성하지 않고 미리 생성해 두고 공유해 사용할 수 있음
- Flyweight 패턴을 통해 미리 생성해둔 객체는 공유의 개념으로 사용되므로 공유할 속성과 공유하지 않을 속성을 구분하여 설계할 필요가 있음
```

Composite 패턴

```
- Composite 패턴은 집합체와 집합체를 구성하는 항목인 단일체를 같은 개념으로 처리합니다.
- 다양한 형태의 단일체를 조합한 집합체를 또 다른 단일체로 정의할 수 있고 이를 단일체나 집합체라는 구분없이 같은 개념으로 처리할 수 있습니다.
```
